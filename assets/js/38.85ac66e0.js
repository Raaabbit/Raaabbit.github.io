(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{461:function(t,v,e){"use strict";e.r(v);var _=e(25),l=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"回流和重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流和重绘"}},[t._v("#")]),t._v(" 回流和重绘")]),t._v(" "),e("h2",{attrs:{id:"浏览器渲染过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[t._v("#")]),t._v(" 浏览器渲染过程")]),t._v(" "),e("p",[t._v("先请今天的主角“回流”和“重绘”在后台等一下，我们先来看看浏览器渲染页面的过程，"),e("strong",[t._v("不要跳过这个重要的部分啊～")])]),t._v(" "),e("p",[t._v("当浏览器得到页面的时候，就开始了它的渲染过程：")]),t._v(" "),e("ol",[e("li",[t._v("解析HTML，构建DOM树（包括了发起http请求来获取链接的内容）")]),t._v(" "),e("li",[t._v("解析CSS")]),t._v(" "),e("li",[t._v("合并DOM树和CSS规则树，生成reader树")]),t._v(" "),e("li",[t._v("布局render树（Layout/reflow），计算元素的位置，大小")]),t._v(" "),e("li",[t._v("绘制render树，绘制页面像素信息")])]),t._v(" "),e("p",[t._v("上面就是大致的流程了，进行一点简单的解释\n###构建DOM树")]),t._v(" "),e("ul",[e("li",[t._v("单个节点的构建经过了"),e("code",[t._v("Bytes -> characters -> tokens -> nodes -> object model")]),t._v("的过程")]),t._v(" "),e("li",[t._v("整个树的构建利用了栈结构，当一个元素的所有子节点构建完成后才去构建下一个兄弟节点（类似深度优先遍历树）")])]),t._v(" "),e("h3",{attrs:{id:"构建cssom树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建cssom树"}},[t._v("#")]),t._v(" 构建CSSOM树")]),t._v(" "),e("p",[t._v("当计算每个节点样式的时候，浏览器会根据优先级从低到高的顺序设置这个节点的属性，从全局属性开始，一直寻找到这个节点的具体属性。这个CSSOM会部分替换浏览器自己的默认样式表。")]),t._v(" "),e("h3",{attrs:{id:"生成render树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生成render树"}},[t._v("#")]),t._v(" 生成render树")]),t._v(" "),e("p",[t._v("这个渲染的过程是从DOM的根节点开始进行render过程，在这个过程中会跳过不占据空间的节点，比如设置了"),e("code",[t._v("display:none")]),t._v("的元素，不包括那些有大小但设置了"),e("code",[t._v("visibility:hidden; opacity:0;")]),t._v("的元素。")]),t._v(" "),e("h2",{attrs:{id:"reflow的触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reflow的触发"}},[t._v("#")]),t._v(" reflow的触发")]),t._v(" "),e("ul",[e("li",[t._v("页面第一次渲染")]),t._v(" "),e("li",[t._v("DOM树发生变化（添加DOM节点、添加内容）")]),t._v(" "),e("li",[t._v("元素位置或大小变化")]),t._v(" "),e("li",[t._v("浏览器窗口大小变化")]),t._v(" "),e("li",[t._v("获取属性（这个影响不在于改变了页面，而是破坏了浏览器的进行的批处理回流优化）")])]),t._v(" "),e("p",[e("strong",[t._v("一些属性和方法")])]),t._v(" "),e("ul",[e("li",[t._v("clientWidth、clientHeight、clientTop、clientLeft")]),t._v(" "),e("li",[t._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),t._v(" "),e("li",[t._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),t._v(" "),e("li",[t._v("scrollIntoView()、scrollIntoViewIfNeeded()")]),t._v(" "),e("li",[t._v("getComputedStyle()")]),t._v(" "),e("li",[t._v("getBoundingClientRect()")]),t._v(" "),e("li",[t._v("scrollTo()")])]),t._v(" "),e("h2",{attrs:{id:"repaint的触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#repaint的触发"}},[t._v("#")]),t._v(" repaint的触发")]),t._v(" "),e("ul",[e("li",[t._v("回流必定会引起重绘")]),t._v(" "),e("li",[t._v("颜色，透明度，字体等属性的改变会引起重绘")])]),t._v(" "),e("p",[t._v("**一个明显的结论：**回流比重绘代价更高")]),t._v(" "),e("h2",{attrs:{id:"优化方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化方法"}},[t._v("#")]),t._v(" 优化方法")]),t._v(" "),e("p",[t._v("浏览器本身是有一定的优化策略的，比如维护一个引起回流 / 重绘的队列，将所有引起回流重绘的操作放入队列，进行批处理。这样就能让多次操作变成一次操作，从而提升效率。同时，如果某些页面内容的改变很重要，想要第一时间完成，也可以写代码强行提前队列操作。")]),t._v(" "),e("p",[e("strong",[t._v("日常注意点：")])]),t._v(" "),e("ul",[e("li",[t._v("将多次页面样式改变合并成一次操作")]),t._v(" "),e("li",[t._v("将需要多次重排的元素，设置为absolute或者fixed，元素脱离了文档流，不会影响别的元素")]),t._v(" "),e("li",[t._v("对一个有多个层次的dom节点，构建完成之后再插入页面中，而不要一步一步添加")]),t._v(" "),e("li",[t._v("可以先把元素display：none，改变内容完成之后再diaplay：block")])])])}),[],!1,null,null,null);v.default=l.exports}}]);